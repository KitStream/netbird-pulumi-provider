// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package index

import (
	"context"
	"reflect"

	"errors"
	"github.com/KitStream/pulumi-netbird/sdk/go/index/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type SetupKey struct {
	pulumi.CustomResourceState

	// Allow extra DNS labels to be added to the peer
	AllowExtraDnsLabels pulumi.BoolOutput `pulumi:"allowExtraDnsLabels"`
	// List of groups to automatically assign to peers created through this setup key
	AutoGroups pulumi.StringArrayOutput `pulumi:"autoGroups"`
	// Indicate that the peer will be ephemeral or not, ephemeral peers are deleted after 10 minutes of inactivity
	Ephemeral pulumi.BoolOutput `pulumi:"ephemeral"`
	// SetupKey Expiration Date
	Expires pulumi.StringOutput `pulumi:"expires"`
	// Expiry time in seconds (0 is unlimited)
	ExpirySeconds pulumi.IntOutput `pulumi:"expirySeconds"`
	// Plaintext setup key
	Key pulumi.StringOutput `pulumi:"key"`
	// Last usage time
	LastUsed pulumi.StringOutput `pulumi:"lastUsed"`
	// SetupKey Name
	Name pulumi.StringOutput `pulumi:"name"`
	// Set to true to revoke setup key
	Revoked pulumi.BoolOutput `pulumi:"revoked"`
	// Setup key state (valid or expired)
	State pulumi.StringOutput `pulumi:"state"`
	// Setup Key type (one-off or reusable)
	Type pulumi.StringOutput `pulumi:"type"`
	// Creation timestamp
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
	// Maximum number of times SetupKey can be used (0 for unlimited)
	UsageLimit pulumi.IntOutput `pulumi:"usageLimit"`
	// Number of times Setup Key was used
	UsedTimes pulumi.IntOutput `pulumi:"usedTimes"`
	// True if setup key can be used to create more Peers
	Valid pulumi.BoolOutput `pulumi:"valid"`
}

// NewSetupKey registers a new resource with the given unique name, arguments, and options.
func NewSetupKey(ctx *pulumi.Context,
	name string, args *SetupKeyArgs, opts ...pulumi.ResourceOption) (*SetupKey, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"key",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SetupKey
	err := ctx.RegisterResource("netbird:index/setupKey:SetupKey", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSetupKey gets an existing SetupKey resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSetupKey(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SetupKeyState, opts ...pulumi.ResourceOption) (*SetupKey, error) {
	var resource SetupKey
	err := ctx.ReadResource("netbird:index/setupKey:SetupKey", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SetupKey resources.
type setupKeyState struct {
	// Allow extra DNS labels to be added to the peer
	AllowExtraDnsLabels *bool `pulumi:"allowExtraDnsLabels"`
	// List of groups to automatically assign to peers created through this setup key
	AutoGroups []string `pulumi:"autoGroups"`
	// Indicate that the peer will be ephemeral or not, ephemeral peers are deleted after 10 minutes of inactivity
	Ephemeral *bool `pulumi:"ephemeral"`
	// SetupKey Expiration Date
	Expires *string `pulumi:"expires"`
	// Expiry time in seconds (0 is unlimited)
	ExpirySeconds *int `pulumi:"expirySeconds"`
	// Plaintext setup key
	Key *string `pulumi:"key"`
	// Last usage time
	LastUsed *string `pulumi:"lastUsed"`
	// SetupKey Name
	Name *string `pulumi:"name"`
	// Set to true to revoke setup key
	Revoked *bool `pulumi:"revoked"`
	// Setup key state (valid or expired)
	State *string `pulumi:"state"`
	// Setup Key type (one-off or reusable)
	Type *string `pulumi:"type"`
	// Creation timestamp
	UpdatedAt *string `pulumi:"updatedAt"`
	// Maximum number of times SetupKey can be used (0 for unlimited)
	UsageLimit *int `pulumi:"usageLimit"`
	// Number of times Setup Key was used
	UsedTimes *int `pulumi:"usedTimes"`
	// True if setup key can be used to create more Peers
	Valid *bool `pulumi:"valid"`
}

type SetupKeyState struct {
	// Allow extra DNS labels to be added to the peer
	AllowExtraDnsLabels pulumi.BoolPtrInput
	// List of groups to automatically assign to peers created through this setup key
	AutoGroups pulumi.StringArrayInput
	// Indicate that the peer will be ephemeral or not, ephemeral peers are deleted after 10 minutes of inactivity
	Ephemeral pulumi.BoolPtrInput
	// SetupKey Expiration Date
	Expires pulumi.StringPtrInput
	// Expiry time in seconds (0 is unlimited)
	ExpirySeconds pulumi.IntPtrInput
	// Plaintext setup key
	Key pulumi.StringPtrInput
	// Last usage time
	LastUsed pulumi.StringPtrInput
	// SetupKey Name
	Name pulumi.StringPtrInput
	// Set to true to revoke setup key
	Revoked pulumi.BoolPtrInput
	// Setup key state (valid or expired)
	State pulumi.StringPtrInput
	// Setup Key type (one-off or reusable)
	Type pulumi.StringPtrInput
	// Creation timestamp
	UpdatedAt pulumi.StringPtrInput
	// Maximum number of times SetupKey can be used (0 for unlimited)
	UsageLimit pulumi.IntPtrInput
	// Number of times Setup Key was used
	UsedTimes pulumi.IntPtrInput
	// True if setup key can be used to create more Peers
	Valid pulumi.BoolPtrInput
}

func (SetupKeyState) ElementType() reflect.Type {
	return reflect.TypeOf((*setupKeyState)(nil)).Elem()
}

type setupKeyArgs struct {
	// Allow extra DNS labels to be added to the peer
	AllowExtraDnsLabels *bool `pulumi:"allowExtraDnsLabels"`
	// List of groups to automatically assign to peers created through this setup key
	AutoGroups []string `pulumi:"autoGroups"`
	// Indicate that the peer will be ephemeral or not, ephemeral peers are deleted after 10 minutes of inactivity
	Ephemeral *bool `pulumi:"ephemeral"`
	// Expiry time in seconds (0 is unlimited)
	ExpirySeconds *int `pulumi:"expirySeconds"`
	// SetupKey Name
	Name string `pulumi:"name"`
	// Set to true to revoke setup key
	Revoked *bool `pulumi:"revoked"`
	// Setup Key type (one-off or reusable)
	Type *string `pulumi:"type"`
	// Maximum number of times SetupKey can be used (0 for unlimited)
	UsageLimit *int `pulumi:"usageLimit"`
}

// The set of arguments for constructing a SetupKey resource.
type SetupKeyArgs struct {
	// Allow extra DNS labels to be added to the peer
	AllowExtraDnsLabels pulumi.BoolPtrInput
	// List of groups to automatically assign to peers created through this setup key
	AutoGroups pulumi.StringArrayInput
	// Indicate that the peer will be ephemeral or not, ephemeral peers are deleted after 10 minutes of inactivity
	Ephemeral pulumi.BoolPtrInput
	// Expiry time in seconds (0 is unlimited)
	ExpirySeconds pulumi.IntPtrInput
	// SetupKey Name
	Name pulumi.StringInput
	// Set to true to revoke setup key
	Revoked pulumi.BoolPtrInput
	// Setup Key type (one-off or reusable)
	Type pulumi.StringPtrInput
	// Maximum number of times SetupKey can be used (0 for unlimited)
	UsageLimit pulumi.IntPtrInput
}

func (SetupKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*setupKeyArgs)(nil)).Elem()
}

type SetupKeyInput interface {
	pulumi.Input

	ToSetupKeyOutput() SetupKeyOutput
	ToSetupKeyOutputWithContext(ctx context.Context) SetupKeyOutput
}

func (*SetupKey) ElementType() reflect.Type {
	return reflect.TypeOf((**SetupKey)(nil)).Elem()
}

func (i *SetupKey) ToSetupKeyOutput() SetupKeyOutput {
	return i.ToSetupKeyOutputWithContext(context.Background())
}

func (i *SetupKey) ToSetupKeyOutputWithContext(ctx context.Context) SetupKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SetupKeyOutput)
}

// SetupKeyArrayInput is an input type that accepts SetupKeyArray and SetupKeyArrayOutput values.
// You can construct a concrete instance of `SetupKeyArrayInput` via:
//
//	SetupKeyArray{ SetupKeyArgs{...} }
type SetupKeyArrayInput interface {
	pulumi.Input

	ToSetupKeyArrayOutput() SetupKeyArrayOutput
	ToSetupKeyArrayOutputWithContext(context.Context) SetupKeyArrayOutput
}

type SetupKeyArray []SetupKeyInput

func (SetupKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SetupKey)(nil)).Elem()
}

func (i SetupKeyArray) ToSetupKeyArrayOutput() SetupKeyArrayOutput {
	return i.ToSetupKeyArrayOutputWithContext(context.Background())
}

func (i SetupKeyArray) ToSetupKeyArrayOutputWithContext(ctx context.Context) SetupKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SetupKeyArrayOutput)
}

// SetupKeyMapInput is an input type that accepts SetupKeyMap and SetupKeyMapOutput values.
// You can construct a concrete instance of `SetupKeyMapInput` via:
//
//	SetupKeyMap{ "key": SetupKeyArgs{...} }
type SetupKeyMapInput interface {
	pulumi.Input

	ToSetupKeyMapOutput() SetupKeyMapOutput
	ToSetupKeyMapOutputWithContext(context.Context) SetupKeyMapOutput
}

type SetupKeyMap map[string]SetupKeyInput

func (SetupKeyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SetupKey)(nil)).Elem()
}

func (i SetupKeyMap) ToSetupKeyMapOutput() SetupKeyMapOutput {
	return i.ToSetupKeyMapOutputWithContext(context.Background())
}

func (i SetupKeyMap) ToSetupKeyMapOutputWithContext(ctx context.Context) SetupKeyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SetupKeyMapOutput)
}

type SetupKeyOutput struct{ *pulumi.OutputState }

func (SetupKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SetupKey)(nil)).Elem()
}

func (o SetupKeyOutput) ToSetupKeyOutput() SetupKeyOutput {
	return o
}

func (o SetupKeyOutput) ToSetupKeyOutputWithContext(ctx context.Context) SetupKeyOutput {
	return o
}

// Allow extra DNS labels to be added to the peer
func (o SetupKeyOutput) AllowExtraDnsLabels() pulumi.BoolOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.BoolOutput { return v.AllowExtraDnsLabels }).(pulumi.BoolOutput)
}

// List of groups to automatically assign to peers created through this setup key
func (o SetupKeyOutput) AutoGroups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.StringArrayOutput { return v.AutoGroups }).(pulumi.StringArrayOutput)
}

// Indicate that the peer will be ephemeral or not, ephemeral peers are deleted after 10 minutes of inactivity
func (o SetupKeyOutput) Ephemeral() pulumi.BoolOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.BoolOutput { return v.Ephemeral }).(pulumi.BoolOutput)
}

// SetupKey Expiration Date
func (o SetupKeyOutput) Expires() pulumi.StringOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.StringOutput { return v.Expires }).(pulumi.StringOutput)
}

// Expiry time in seconds (0 is unlimited)
func (o SetupKeyOutput) ExpirySeconds() pulumi.IntOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.IntOutput { return v.ExpirySeconds }).(pulumi.IntOutput)
}

// Plaintext setup key
func (o SetupKeyOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.StringOutput { return v.Key }).(pulumi.StringOutput)
}

// Last usage time
func (o SetupKeyOutput) LastUsed() pulumi.StringOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.StringOutput { return v.LastUsed }).(pulumi.StringOutput)
}

// SetupKey Name
func (o SetupKeyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Set to true to revoke setup key
func (o SetupKeyOutput) Revoked() pulumi.BoolOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.BoolOutput { return v.Revoked }).(pulumi.BoolOutput)
}

// Setup key state (valid or expired)
func (o SetupKeyOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// Setup Key type (one-off or reusable)
func (o SetupKeyOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

// Creation timestamp
func (o SetupKeyOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

// Maximum number of times SetupKey can be used (0 for unlimited)
func (o SetupKeyOutput) UsageLimit() pulumi.IntOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.IntOutput { return v.UsageLimit }).(pulumi.IntOutput)
}

// Number of times Setup Key was used
func (o SetupKeyOutput) UsedTimes() pulumi.IntOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.IntOutput { return v.UsedTimes }).(pulumi.IntOutput)
}

// True if setup key can be used to create more Peers
func (o SetupKeyOutput) Valid() pulumi.BoolOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.BoolOutput { return v.Valid }).(pulumi.BoolOutput)
}

type SetupKeyArrayOutput struct{ *pulumi.OutputState }

func (SetupKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SetupKey)(nil)).Elem()
}

func (o SetupKeyArrayOutput) ToSetupKeyArrayOutput() SetupKeyArrayOutput {
	return o
}

func (o SetupKeyArrayOutput) ToSetupKeyArrayOutputWithContext(ctx context.Context) SetupKeyArrayOutput {
	return o
}

func (o SetupKeyArrayOutput) Index(i pulumi.IntInput) SetupKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SetupKey {
		return vs[0].([]*SetupKey)[vs[1].(int)]
	}).(SetupKeyOutput)
}

type SetupKeyMapOutput struct{ *pulumi.OutputState }

func (SetupKeyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SetupKey)(nil)).Elem()
}

func (o SetupKeyMapOutput) ToSetupKeyMapOutput() SetupKeyMapOutput {
	return o
}

func (o SetupKeyMapOutput) ToSetupKeyMapOutputWithContext(ctx context.Context) SetupKeyMapOutput {
	return o
}

func (o SetupKeyMapOutput) MapIndex(k pulumi.StringInput) SetupKeyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SetupKey {
		return vs[0].(map[string]*SetupKey)[vs[1].(string)]
	}).(SetupKeyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SetupKeyInput)(nil)).Elem(), &SetupKey{})
	pulumi.RegisterInputType(reflect.TypeOf((*SetupKeyArrayInput)(nil)).Elem(), SetupKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SetupKeyMapInput)(nil)).Elem(), SetupKeyMap{})
	pulumi.RegisterOutputType(SetupKeyOutput{})
	pulumi.RegisterOutputType(SetupKeyArrayOutput{})
	pulumi.RegisterOutputType(SetupKeyMapOutput{})
}
